#! /bin/bash

ADDRESS='0.0.0.0'
PORT='8080'
DIR='.'

fatal () {
    echo '[Fatal]' "$@" >&2
}

parse-request() {
    # Define global array of http request
    declare -gA REQ_INFO=()
    declare -gA REQ_HEADERS=()

    local state='status'
    local line
    # Start parsing request based on HTTP/1.1 Specification
    while read -r line; do
        line=${line%$'\r'}
        case "$state" in
                'status')
                    # parse the status line
                    # "GET" /foo.txt HTTP/1.1"
                    local method path version
                    read -r method path version <<< "$line"
                    REQ_INFO[method]=$method
                    REQ_INFO[path]=$path
                    REQ_INFO[version]=$version
                    state='headers'
                    ;;
                'headers')
                    # parse the headers
                    if [[ -z $line ]]; then
                        # this doesn't support body parsing
                        break
                    fi
                    local key value
                    # Use IFS delimiter ':' to parse line
                    IFS=: read -r key value <<< "$line"
                    key=${key,,} 
                    # Grab value and delete trailing spaces
                    value=${value# *}
                    REQ_HEADERS[$key]=$value
                    ;;
                'body')
                    fatal 'body parsing not supported'
                    ;;
        esac
    done
}

html-encode() {
    local s=$1

    # Encode special characters
    s=${s//&/&amp;}
    s=${s//</&lt;}
    s=${s//>/&gt;}
    s=${s//\"/&quot;}
    s=${s//\'/&apos;}

    echo "$s"

}

list-directory () {
    # Pass in directory
    local d=$1

    # Find all files and exclude '*'
    shopt -s nullglob dotglob    
    echo '<h1>Directory Listing</h1>'
    echo "<h2>Directory: $(html-encode "$d")</h2>"
    echo '<hr>'
    echo '<ul>'

    # Parse all file names
    for f in .. "$d"/*; do
        f=${f##*/}
        printf '<li><a href="%s">%s</a></li>\n' \
                "$(urlencode "$f")" \
                "$(html-encode "$f")"
    done
    echo '</ul>'
    echo '<hr>'
}

mime-type() {
    # Parse filename and find extension
    local f=$1
    # File name
    local bname=${f##*/}
    # Remove file name and grab everything after '.'
    local ext=${bname##*.}
    [[ $bname == "$ext" ]] && ext=

    # Content-type
    case "$ext" in 
        html|htm) echo 'text/html';;
        jpeg|jpg) echo 'image/jpeg';;
        png) echo 'image/png';;
        txt) echo 'text/plain';;
        css) echo 'text/css';;
        js) echo 'text/javascript';;
        json) echo 'application/json';;
        *) echo 'application/octet-stream';;
    esac
}

urldecode() {
    # Usage: urldecode "string"
    : "${1//+/ }"
    printf '%b\n' "${_//%/\\x}"
}

urldecode() {
    # Usage: urldecode "string"
    : "${1//+/ }"
    printf '%b\n' "${_//%/\\x}"
}

urlencode() {
    # Usage: urlencode "string"
    local LC_ALL=C
    for (( i = 0; i < ${#1}; i++ )); do
        : "${1:i:1}"
        case "$_" in
            [a-zA-Z0-9.~_-])
                printf '%s' "$_"
            ;;

            *)
                printf '%%%02X' "'$_"
            ;;
        esac
    done
    printf '\n'
}

normalize-path() {
    local path=/$1

    local -a parts
    local -a out=()
    # Use delimiter to parse path and pop the last directory for '..'
    IFS='/' read -r -a parts <<< "$path"
    for part in "${parts[@]}"; do
        case "$part" in
            '') ;;
            '.') ;;
            '..') unset 'out[-1]' 2>/dev/null;;
            *) out+=("$part");;
        esac
    done
    
    local s
    s=$(IFS=/;  echo "${out[*]}")
    echo "/$s"
}

process-request() {
    local fd=$1

    parse-request <&"$fd"

    # validate request
    [[ ${REQ_INFO[version]} == 'HTTP/1.1' ]] || fatal 'unsupported HTTP version'
    [[ ${REQ_INFO[method]} == 'GET' ]] || fatal 'unsupported HTTP method'
    [[ ${REQ_INFO[path]} == /* ]] || fatal 'path must be absolute'

    echo "${REQ_INFO[method]} ${REQ_INFO[path]}"
    path=${path:1}

    # removing beginning slash
    local path="${REQ_INFO[path]}"

    # query parsing
    local query
    IFS='?' read -r path query <<< "$path"
    path=$(urldecode "$path")

    # normalizing path
    path=$(normalize-path "$path")
    path=${path:1}

    # handle empty path
    path=${path:-.}

    # try to serve an index page
    local totry=(
        "$path",
        "$path/index.html"
        "$path/index.htm"
    )

    local try file
    for try in "${totry[@]}"; do
        if [[ -f $try ]]; then
            file=$try
            break
        fi
    done

    # File handling, directory handling
    if [[ -n $file ]]; then
        mime=$(mime-type "$file")
        printf 'HTTP/1.1 200 OK\r\n' >&"$fd"
        printf 'Content-Type: %s\r\n' "$mime" >&"$fd"
        printf '\r\n' >&"$fd"
        cat "$file" >&"$fd"
        printf '\r\n' >&"$fd"
    elif [[ -d $path ]]; then
        # directory listing
        printf 'HTTP/1.1 200 OK\r\n' >&"$fd"
        printf 'Content-Type: text/html\r\n' $mime>&"$fd"
        printf '\r\n' >&"$fd"
        list-directory "$path" >&"$fd"
    else 
        # nothing was found
        printf 'HTTP/1.1 404 Not Found\r\n' >&"$fd"
        printf '\r\n' >&"$fd"
    fi
}

main() {
    # Requires bash-builtins package 'apt install bash-builtins'
    # Socket reading program
    enable accept || fatal 'failed to load accept'

    # Add customized address, port, and directory with flags
    # ./bash-web-server -b 0.0.0.0 -p 9000 -d ..
    local OPTIND OPTARG opt
    while getopts 'b:p:d:' opt; do
        case "$opt" in 
            b) ADDRESS=$OPTARG;;
            p) PORT=$OPTARG;;
            d) DIR=$OPTARG;;
            *) fatal "bad option";;
        esac
    done

    cd "$DIR" || fatal "failed to move to $DIR"

    echo "listening on http://$ADDRESS:$PORT"
    local fd ip
    # Store file descriptor number in a var with '-v filedescriptor'
    while true; do
        accept -b "$ADDRESS" -v fd -r ip $PORT || fatal 'failed to read socket'
        
        # Create a forked process and run in background
        process-request "$fd" &
        # Kill current process and let child process parse the request
        exec {fd}>&-
    done
}

main "$@"